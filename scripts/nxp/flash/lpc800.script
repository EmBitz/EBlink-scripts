/////////////////////////////////////////////////////////////////////////////////
//
//          LPC800
//
//
// Adapted from stmicro scripts by J.DuBois
// at Thermalogic Corporation (jer@thlogic.com)

const IAP_ADDR    0x0F001FF1

const DATA_ADDR   0x10000050
const RETURN_ADDR 0x10000010
const PARAM_ADDR  0x10000020
const RESULT_ADDR 0x10000034

const IAP_PREPARESECTORS 50
const IAP_COPYRAMTOFLASH 51
const IAP_ERASESECTORS   52
const IAP_BLANKCHECK     53
const IAP_READPARTID     54
const IAP_READBOOTVERS   55
const IAP_COMPARE        56
const IAP_REINVOKEISP    57
const IAP_READSERIAL     58
const IAP_ERASEPAGES     59

/////////////////////////////////////////////////////////////////////////////////
//
//   Called by EBlink to initialize upcoming flash operations.
//
function flash_start()
{
   try {
        // Be sure that the core is halted
        targetApi.reset(SYSTEM_RESET)

        // Wait for halt
        local time = GetTickCount()
        do{
            // Timeout of 1sec
            if(GetTickCount() - time > 1000)
            throw ERROR_TIMEOUT

            targetApi.poll()
        } while(targetApi.getState() != TARGET_HALTED )

        // Make sure boot ROM routines are mapped
        intrfApi.write(0x40048000,0x0)

        // Set Stack Pointer to not interfere with flash routines
        targetApi.writeReg("SP", 0x100007E0)

        return ERROR_OK
    }

    // Catch all the sector write errors
    catch(e){
       flash_done()
       if(catchString(e))
            return ERROR_NOTIFIED
       if(e < ERROR_NOTIFIED)
           errorf("ERROR: couldn't initialize target! [%s]\n", errorToStr(e) )
       return ERROR_NOTIFIED
    }
}

/////////////////////////////////////////////////////////////////////////////////
//
//   Called by EBlink to erase a sector
//    - flash_start() is already called
//    - flash_done() will be called if all flash operations are ready
//
function flash_erase(sector, address)
{
    try {
        local result=[0,0,0,0],page

        if (sector < 15) {
            // Prepare sector for writing
            executeIAP(IAP_PREPARESECTORS,result,sector,sector)

            // Copy data from RAM to FLASH
            executeIAP(IAP_ERASESECTORS,result,sector,sector,12000)
        }
        else {
            // Convert sector to page
            page = 15*16+(sector-15)

            // Prepare sector for writing
            executeIAP(IAP_PREPARESECTORS,result,page/16,page/16)

            // Copy data from RAM to FLASH
            executeIAP(IAP_ERASEPAGES,result,page,page,12000)
        }

        if (result[0] != 0)
            throw ERROR_FLASH

        return ERROR_OK
    }

    // Catch all the sector erase errors
    catch(e){
       flash_done()
       if(catchString(e))
            return ERROR_NOTIFIED
       if(e < ERROR_NOTIFIED)
           errorf("ERROR: erasing sector %d failed! [%s]\n", sector, errorToStr(e) )
       return ERROR_NOTIFIED
    }
}


/////////////////////////////////////////////////////////////////////////////////
//
//  Called by EBlink to write a sector.
//
function flash_write(sector, address, buffer)
{
    try {
        local result=[1,0,0,0],writeSize,page;

        writeSize = buffer.getSize();

        // We can only write in blocks of 64, 128, 256, 512, or 1024 bytes
        if (writeSize < 64) writeSize == 64;
        else if (writeSize < 128) writeSize = 128;
        else if (writeSize < 256) writeSize = 256;
        else if (writeSize < 512) writeSize = 512;
        else writeSize = 1024;

        // Write buffer to RAM
        intrfApi.writeBuf(buffer, DATA_ADDR)

        // Fill up any remaining bytes in the block with 0xFF
        for (local i=buffer.getSize()/4*4;i<writeSize;i+=4) {
            intrfApi.write(DATA_ADDR+i, 0x0)
        }

        if (sector < 15) {
            // Prepare sector for writing
            executeIAP(IAP_PREPARESECTORS,result,sector,sector,0)

            // Copy data from RAM to FLASH
            executeIAP(IAP_COPYRAMTOFLASH,result,address,DATA_ADDR,writeSize,12000)
            if (result[0] != 0)
                throw ERROR_FLASH
        }
        else {
            // Convert sector to page
            page = 15*16+(sector-15)

            // Prepare sector for writing
            executeIAP(IAP_PREPARESECTORS,result,address/1024,address/1024,0)

            // Copy data from RAM to FLASH
            executeIAP(IAP_COPYRAMTOFLASH,result,address,DATA_ADDR,64,12000)

            if (result[0] != 0)
               throw ERROR_FLASH
        }

        return ERROR_OK
    }

    // Catch all the sector write errors
    catch(e){
        flash_done()
        if(catchString(e))
            return ERROR_NOTIFIED
        if(e < ERROR_NOTIFIED)
           errorf("ERROR: writing sector %d failed! [%s]\n", sector, errorToStr(e) )
        return ERROR_NOTIFIED
    }
}

/////////////////////////////////////////////////////////////////////////////////
//
// Called by EBlink if all flash operations are ready
//
function flash_done()
{
  try
  {
    // Unmap the boot loader from the first 512 bytes of memory
    intrfApi.write(0x40048000,0x02)

    // Set the Stack pointer according the Vector table entry
    targetApi.writeReg("SP", intrfApi.read(0x00000000))

    // Set the Program pointer according the Vector table entry
    targetApi.writeReg("PC", intrfApi.read(0x00000004))
    return ERROR_OK
  }
  catch(e){
    if(catchString(e))
       return ERROR_NOTIFIED
    if(e < ERROR_NOTIFIED)
       errorf("ERROR: Flash done\n" )
    return ERROR_NOTIFIED
  }
}

/////////////////////////////////////////////////////////////////////////////////
//
//  Called by EBlink if chip erase is needed (e.g. command line flashing)
//
//   Erase the whole chip
//   - If this function is not defined, sector by sector erase is used by EBlink.
//   - This is an isolated function, flash_start and flash_done are not called by EBlink
//
function flash_erase_chip()
{
    try {
        local result=[1,0,0,0]

        if( flash_start() != ERROR_OK)
            throw ERROR_FLASH

        // Prepare all sectors for erasing
        executeIAP(IAP_PREPARESECTORS,result,0,15)

        // Erase all sectors
        executeIAP(IAP_ERASESECTORS,result,0,15)
        if (result[0] != 0)
            throw ERROR_FLASH

        flash_done()
        return ERROR_OK
    }

    // Catch all the sector erase errors
    catch(e){
       flash_done()
       if(catchString(e))
            return ERROR_NOTIFIED
       if(e < ERROR_NOTIFIED)
           errorf("ERROR: erasing chip failed! [%s]\n", errorToStr(e) )
       return ERROR_NOTIFIED
    }
}


/////////////////////////////////////////////////////////////////////////////////////////
//
function executeIAP(cmd,result,...)
{
    local i

    targetApi.halt()

    intrfApi.write(RESULT_ADDR, 1)

    // Write params to data ram space
    intrfApi.write(PARAM_ADDR, cmd)
    for (i=0;i < 4 && i < vargv.len();i++) {
        intrfApi.write(PARAM_ADDR+(i+1)*4, vargv[i])
    }

    // Write the param and result addresses into R0/R1
    targetApi.writeReg("R0", PARAM_ADDR)
    targetApi.writeReg("R1", RESULT_ADDR)

    // Write the return address to the LR register, and set the BKPT instruction at
    // the return address
    targetApi.writeReg("LR", RETURN_ADDR+1)
    intrfApi.write(RETURN_ADDR, 0xBEAABEAA)

    // Execute the IAP command
    targetApi.execute(IAP_ADDR, true)

    // Return results
    for (i=0;i<3;i++) {
        result[i] = intrfApi.read(RESULT_ADDR+i*4)
    }
}
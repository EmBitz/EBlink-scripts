//! NXP lpc
// Adapted from stmicro scripts by J.DuBois
// at Thermalogic Corporation (jer@thlogic.com)
//
/////////////////////////////////////////////////////
//
//     This is a virtual device for NXP LPC cortex's
//     The real device type is checked by reading
//     the device ID and include the corresponding
//     device script's
//
//     The script tries to detect the right memory sizes
//     however, if this is not correct you can set the sizes
//     in kilobytes on the command line as:
//
//         -D FLASH_SIZE=xxx  and -D RAM_SIZE=xxxx  (check also device scripts)
//

intrfApi <- InterfAPI()  // Global so that all included script files also have access
targetApi<- TargetAPI()  // Global interface to the target class
deviceId <- 0            // Global deviceId
deviceType <- 0			 // Global deviceType

// Used by script to denote a not found devcie
const ERROR_NOT_FOUND -100

const K32_DEV_ID   0x40075024	// Device Id Register on K32 devices
const BKPT	   0xBEAABEAA	// Breakpoint instruction
const IAP_SIG	   0xF7FEB510	// Signature to identify that IAP entry point exists
const IAP_SIG_176X 0xBA72F700	// Signature to identify that IAP entry point exists for LPC176x devices
const IAP_ADDR     0x1FFF1FF1	// IAP entry point
const IAP_ADDR_800 0x0F001FF1	// IAP entry point for LPC800 series
const RETURN_ADDR  0x10000010
const PARAM_ADDR   0x10000030
const RESULT_ADDR  0x100000D0

const IAP_READPARTID 54

const NXP_LPC 0
const NXP_K32 1
/////////////////////////////////////////////////////
//
//  EBlink called Entry point
//

function main()
{

    try {
        findDevice()
    }
    catch(e)
    {
        if( e == ERROR_NOT_FOUND)
            if(deviceId) {
                printf("\n\nPlease report this ID so that we can add it.\n")
                errorf("Error unsupported NXP LPC ID: 0x%X\n", deviceId)
            }
            else
                errorf("ERROR: No valid NXP LPC device ID found\n")
        else
            errorf("Error:\tCan't access target device!\n\tIf reset is disabled (\"dr\" option), try with reset.")
        return ERROR_NOTIFIED  // We have already thrown an error so use -1 (otherwise < -1)
    }
    return ERROR_OK
}

/////////////////////////////////////////////////////
//
//
//
function findDevice()
{
    // Check if the right script API is supported
    if( VERSION < 4.7) {
       errorf("Error:\n\nIncompatiable EBlink version %.1f\n\tPlease update\n", VERSION)
       throw ERROR_NOTIFIED
    }

    // Read the K32 Deivce ID
    deviceId = readK32DeviceID()
    
    // If zero, read the LPC Device ID
    if (deviceId == 0) 
        deviceId = readLPCDeviceID()

	if(deviceId == 0)
        	throw ERROR_NOT_FOUND

	// We have valid device LPC ID which will be used to load the right scripts
	set_target(NXP_LPC)
    }
    
    // We have valid device K32 ID which will be used to load the right scripts
    else set_target(NXP_K32)
}

/////////////////////////////////////////////////////
//
//
//
function readK32DeviceID()
{

  _n_throw(intrfApi.readMem32(K32_DEV_ID))
  
  if (!(intrfApi.value32 & 0x10000)) return(0)
  
  return(intrfApi.value32)
}

/////////////////////////////////////////////////////
//
//
//
function readLPCDeviceID()
{
   _n_throw( targetApi.halt() )

   // Check to make sure we're dealing with an NXP LPC device by
   // looking for the IAP signature at the IAP routine memory locations

   _n_throw(intrfApi.readMem32(IAP_ADDR))

   if (intrfApi.value32 != IAP_SIG && intrfApi.value32 != IAP_SIG_176X) {
	 _n_throw(intrfApi.readMem32(IAP_ADDR_800))
	 if (intrfApi.value32 != IAP_SIG) return(0)
   }

   // Write params to data ram space
   _n_throw( intrfApi.writeMem32(PARAM_ADDR, IAP_READPARTID) )
   _n_throw( intrfApi.writeMem32(RESULT_ADDR+4,0) )

   // Write the param and result addresses into R0/R1
   _n_throw( targetApi.writeReg("R0", PARAM_ADDR) )
   _n_throw( targetApi.writeReg("R1", RESULT_ADDR) )

   // Write the return address to the LR register, and set the BKPT instruction at
   // the return address
   _n_throw( targetApi.writeReg("LR", RETURN_ADDR+1) )
   _n_throw( intrfApi.writeMem32(RETURN_ADDR, BKPT) )

   // Execute the IAP command (If there's nothing at the standard IAP entry address,
   // try the LPC800 entry address)
   _n_throw(intrfApi.readMem32(IAP_ADDR_800))

   if (intrfApi.value32 == IAP_SIG)
	_n_throw( targetApi.execute(IAP_ADDR_800, true) )
   else
	_n_throw( targetApi.execute(IAP_ADDR, true) )

   // Read result
   _n_throw( intrfApi.readMem32(RESULT_ADDR+4) )

// Return result

   return(intrfApi.value32)

}

/////////////////////////////////////////////////////
//
//
//
function set_target(type)
{
    noticef("NXP device : 0x%X\n", deviceId)

    if (type == NXP_LPC) {
    
    	if (deviceId >= 0x00008021 && deviceId <= 0x00008044)
		require("nxp/lpc800.script")

    	else if ((deviceId >= 0x25001110 && deviceId <= 0x25113737) ||
		     (deviceId >= 0x26011922 && deviceId <= 0x26113F37))
        	require("nxp/lpc1700.script")

    	else
        	require("nxp/lpc1100.script")

	// Call our generic entry point of the device script we just loaded
    	lpc_device()
    }
    else {
    
    	require("nxp/k32.script")
	k32_device()
    }
}

/////////////////////////////////////////////////////////////////////////////////
//
// Additional commands after reset (optional) called by EBlink
//
// resetType:
//        SYSTEM_RESET
//        CORE_RESET
//        JTAG_RESET
//        USER_RESET
//
function  reset_post(resetType)
{

    // Check if there is an user defined post reset hook, the user
    // can add his own reset strategy with -S <myscript> as last
    // defined script on the cli.
    if (isScriptObject("reset_post_hook"))
        return reset_post_hook(resetType);

    // We don't use this if the reset is a user_script type. In that
    // case, the user is responsible for the initialization.
    //
    if( resetType != USER_RESET )
    {
        // The reset strategies are defined in (lower) part definition scripts
    }

    return ERROR_OK
}

